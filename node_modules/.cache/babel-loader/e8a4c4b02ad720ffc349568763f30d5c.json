{"ast":null,"code":"/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true*/\n(function () {\n  \"use strict\"; // \"FIFO\" isn't easy to convert to camelCase and back reliably\n\n  var isFnodeTypes = [\"isFile\", \"isDirectory\", \"isSymbolicLink\", \"isBlockDevice\", \"isCharacterDevice\", \"isFIFO\", \"isSocket\"],\n      fnodeTypes = [\"file\", \"directory\", \"symbolicLink\", \"blockDevice\", \"characterDevice\", \"FIFO\", \"socket\"],\n      fnodeTypesPlural = [\"files\", \"directories\", \"symbolicLinks\", \"blockDevices\", \"characterDevices\", \"FIFOs\", \"sockets\"]; // \n\n  function createNodeGroups() {\n    var nodeGroups = {};\n    fnodeTypesPlural.concat(\"nodes\", \"errors\").forEach(function (fnodeTypePlural) {\n      nodeGroups[fnodeTypePlural] = [];\n    });\n    return nodeGroups;\n  } // Determine each file node's type\n  // \n\n\n  function sortFnodesByType(stat, fnodes) {\n    var i, isType;\n\n    for (i = 0; i < isFnodeTypes.length; i += 1) {\n      isType = isFnodeTypes[i];\n\n      if (stat[isType]()) {\n        stat.type = fnodeTypes[i];\n        fnodes[fnodeTypesPlural[i]].push(stat);\n        return;\n      }\n    }\n  } // Get the current number of listeners (which may change)\n  // Emit events to each listener\n  // Wait for all listeners to `next()` before continueing\n  // (in theory this may avoid disk thrashing)\n\n\n  function emitSingleEvents(emitter, path, stats, next, self) {\n    var num = 1 + emitter.listeners(stats.type).length + emitter.listeners(\"node\").length;\n\n    function nextWhenReady(flag) {\n      if (flag) {\n        stats.flag = flag;\n      }\n\n      num -= 1;\n\n      if (0 === num) {\n        next.call(self);\n      }\n    }\n\n    emitter.emit(stats.type, path, stats, nextWhenReady);\n    emitter.emit(\"node\", path, stats, nextWhenReady);\n    nextWhenReady();\n  } // Since the risk for disk thrashing among anything\n  // other than files is relatively low, all types are\n  // emitted at once, but all must complete before advancing\n\n\n  function emitPluralEvents(emitter, path, nodes, next, self) {\n    var num = 1;\n\n    function nextWhenReady() {\n      num -= 1;\n\n      if (0 === num) {\n        next.call(self);\n      }\n    }\n\n    fnodeTypesPlural.concat([\"nodes\", \"errors\"]).forEach(function (fnodeType) {\n      if (0 === nodes[fnodeType].length) {\n        return;\n      }\n\n      num += emitter.listeners(fnodeType).length;\n      emitter.emit(fnodeType, path, nodes[fnodeType], nextWhenReady);\n    });\n    nextWhenReady();\n  }\n\n  module.exports = {\n    emitNodeType: emitSingleEvents,\n    emitNodeTypeGroups: emitPluralEvents,\n    isFnodeTypes: isFnodeTypes,\n    fnodeTypes: fnodeTypes,\n    fnodeTypesPlural: fnodeTypesPlural,\n    sortFnodesByType: sortFnodesByType,\n    createNodeGroups: createNodeGroups\n  };\n})();","map":{"version":3,"sources":["C:/Users/H P/node_modules/walk/lib/node-type-emitter.js"],"names":["isFnodeTypes","fnodeTypes","fnodeTypesPlural","createNodeGroups","nodeGroups","concat","forEach","fnodeTypePlural","sortFnodesByType","stat","fnodes","i","isType","length","type","push","emitSingleEvents","emitter","path","stats","next","self","num","listeners","nextWhenReady","flag","call","emit","emitPluralEvents","nodes","fnodeType","module","exports","emitNodeType","emitNodeTypeGroups"],"mappings":"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","sourcesContent":["/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true*/\n(function () {\n  \"use strict\";\n\n  // \"FIFO\" isn't easy to convert to camelCase and back reliably\n  var isFnodeTypes = [\n      \"isFile\", \"isDirectory\",  \"isSymbolicLink\", \"isBlockDevice\",  \"isCharacterDevice\", \"isFIFO\", \"isSocket\"\n    ],\n    fnodeTypes = [\n      \"file\",   \"directory\",    \"symbolicLink\",   \"blockDevice\",    \"characterDevice\",    \"FIFO\",   \"socket\"\n    ],\n    fnodeTypesPlural = [\n      \"files\",  \"directories\",  \"symbolicLinks\",  \"blockDevices\",   \"characterDevices\",   \"FIFOs\",  \"sockets\"\n    ];\n\n\n  // \n  function createNodeGroups() {\n    var nodeGroups = {};\n    fnodeTypesPlural.concat(\"nodes\", \"errors\").forEach(function (fnodeTypePlural) {\n      nodeGroups[fnodeTypePlural] = [];\n    });\n    return nodeGroups;\n  }\n\n\n  // Determine each file node's type\n  // \n  function sortFnodesByType(stat, fnodes) {\n    var i, isType;\n\n    for (i = 0; i < isFnodeTypes.length; i += 1) {\n      isType = isFnodeTypes[i];\n      if (stat[isType]()) {\n        stat.type = fnodeTypes[i];\n        fnodes[fnodeTypesPlural[i]].push(stat);\n        return;\n      }\n    }\n  }\n\n\n  // Get the current number of listeners (which may change)\n  // Emit events to each listener\n  // Wait for all listeners to `next()` before continueing\n  // (in theory this may avoid disk thrashing)\n  function emitSingleEvents(emitter, path, stats, next, self) {\n    var num = 1 + emitter.listeners(stats.type).length + emitter.listeners(\"node\").length;\n\n    function nextWhenReady(flag) {\n      if (flag) {\n        stats.flag = flag;\n      }\n      num -= 1;\n      if (0 === num) { next.call(self); }\n    }\n\n    emitter.emit(stats.type, path, stats, nextWhenReady);\n    emitter.emit(\"node\", path, stats, nextWhenReady);\n    nextWhenReady();\n  }\n\n\n  // Since the risk for disk thrashing among anything\n  // other than files is relatively low, all types are\n  // emitted at once, but all must complete before advancing\n  function emitPluralEvents(emitter, path, nodes, next, self) {\n    var num = 1;\n\n    function nextWhenReady() {\n      num -= 1;\n      if (0 === num) { next.call(self); }\n    }\n\n    fnodeTypesPlural.concat([\"nodes\", \"errors\"]).forEach(function (fnodeType) {\n      if (0 === nodes[fnodeType].length) { return; }\n      num += emitter.listeners(fnodeType).length;\n      emitter.emit(fnodeType, path, nodes[fnodeType], nextWhenReady);\n    });\n    nextWhenReady();\n  }\n\n  module.exports = {\n    emitNodeType: emitSingleEvents,\n    emitNodeTypeGroups: emitPluralEvents,\n    isFnodeTypes: isFnodeTypes,\n    fnodeTypes: fnodeTypes,\n    fnodeTypesPlural: fnodeTypesPlural,\n    sortFnodesByType: sortFnodesByType,\n    createNodeGroups: createNodeGroups\n  };\n}());\n"]},"metadata":{},"sourceType":"script"}