{"ast":null,"code":"// Adapted from work by jorge@jorgechamorro.com on 2010-11-25\n(function () {\n  \"use strict\";\n\n  function noop() {}\n\n  var fs = require('fs'),\n      forEachAsync = require('foreachasync').forEachAsync,\n      EventEmitter = require('events').EventEmitter,\n      TypeEmitter = require('./node-type-emitter'),\n      util = require('util'),\n      path = require('path');\n\n  function appendToDirs(stat) {\n    /*jshint validthis:true*/\n    if (stat.flag && stat.flag === NO_DESCEND) {\n      return;\n    }\n\n    this.push(stat.name);\n  }\n\n  function wFilesHandlerWrapper(items) {\n    /*jshint validthis:true*/\n    this._wFilesHandler(noop, items);\n  }\n\n  function Walker(pathname, options, sync) {\n    EventEmitter.call(this);\n    var me = this;\n    options = options || {};\n    me._wStat = options.followLinks && 'stat' || 'lstat';\n    me._wStatSync = me._wStat + 'Sync';\n    me._wsync = sync;\n    me._wq = [];\n    me._wqueue = [me._wq];\n    me._wcurpath = undefined;\n    me._wfilters = options.filters || [];\n    me._wfirstrun = true;\n    me._wcurpath = pathname;\n\n    if (me._wsync) {\n      //console.log('_walkSync');\n      me._wWalk = me._wWalkSync;\n    } else {\n      //console.log('_walkASync');\n      me._wWalk = me._wWalkAsync;\n    }\n\n    options.listeners = options.listeners || {};\n    Object.keys(options.listeners).forEach(function (event) {\n      var callbacks = options.listeners[event];\n\n      if ('function' === typeof callbacks) {\n        callbacks = [callbacks];\n      }\n\n      callbacks.forEach(function (callback) {\n        me.on(event, callback);\n      });\n    });\n\n    me._wWalk();\n  } // Inherits must come before prototype additions\n\n\n  util.inherits(Walker, EventEmitter);\n\n  Walker.prototype._wLstatHandler = function (err, stat) {\n    var me = this;\n    stat = stat || {};\n    stat.name = me._wcurfile;\n\n    if (err) {\n      stat.error = err; //me.emit('error', curpath, stat);\n      // TODO v3.0 (don't noop the next if there are listeners)\n\n      me.emit('nodeError', me._wcurpath, stat, noop);\n\n      me._wfnodegroups.errors.push(stat);\n\n      me._wCurFileCallback();\n    } else {\n      TypeEmitter.sortFnodesByType(stat, me._wfnodegroups); // NOTE: wCurFileCallback doesn't need thisness, so this is okay\n\n      TypeEmitter.emitNodeType(me, me._wcurpath, stat, me._wCurFileCallback, me);\n    }\n  };\n\n  Walker.prototype._wFilesHandler = function (cont, file) {\n    var statPath,\n        me = this;\n    me._wcurfile = file;\n    me._wCurFileCallback = cont;\n    me.emit('name', me._wcurpath, file, noop);\n    statPath = me._wcurpath + path.sep + file;\n\n    if (!me._wsync) {\n      // TODO how to remove this anony?\n      fs[me._wStat](statPath, function (err, stat) {\n        me._wLstatHandler(err, stat);\n      });\n\n      return;\n    }\n\n    try {\n      me._wLstatHandler(null, fs[me._wStatSync](statPath));\n    } catch (e) {\n      me._wLstatHandler(e);\n    }\n  };\n\n  Walker.prototype._wOnEmitDone = function () {\n    var me = this,\n        dirs = [];\n\n    me._wfnodegroups.directories.forEach(appendToDirs, dirs);\n\n    dirs.forEach(me._wJoinPath, me);\n\n    me._wqueue.push(me._wq = dirs);\n\n    me._wNext();\n  };\n\n  Walker.prototype._wPostFilesHandler = function () {\n    var me = this;\n\n    if (me._wfnodegroups.errors.length) {\n      // TODO v3.0 (don't noop the next)\n      // .errors is an array of stats with { name: name, error: error }\n      me.emit('errors', me._wcurpath, me._wfnodegroups.errors, noop);\n    } // XXX emitNodeTypes still needs refactor\n\n\n    TypeEmitter.emitNodeTypeGroups(me, me._wcurpath, me._wfnodegroups, me._wOnEmitDone, me);\n  };\n\n  Walker.prototype._wReadFiles = function () {\n    var me = this;\n\n    if (!me._wcurfiles || 0 === me._wcurfiles.length) {\n      return me._wNext();\n    } // TODO could allow user to selectively stat\n    // and don't stat if there are no stat listeners\n\n\n    me.emit('names', me._wcurpath, me._wcurfiles, noop);\n\n    if (me._wsync) {\n      me._wcurfiles.forEach(wFilesHandlerWrapper, me);\n\n      me._wPostFilesHandler();\n    } else {\n      forEachAsync(me._wcurfiles, me._wFilesHandler, me).then(me._wPostFilesHandler);\n    }\n  };\n\n  Walker.prototype._wReaddirHandler = function (err, files) {\n    var fnodeGroups = TypeEmitter.createNodeGroups(),\n        me = this,\n        parent,\n        child;\n    me._wfnodegroups = fnodeGroups;\n    me._wcurfiles = files; // no error, great\n\n    if (!err) {\n      me._wReadFiles();\n\n      return;\n    } // TODO path.sep\n\n\n    me._wcurpath = me._wcurpath.replace(/\\/$/, ''); // error? not first run? => directory error\n\n    if (!me._wfirstrun) {\n      // TODO v3.0 (don't noop the next if there are listeners)\n      me.emit('directoryError', me._wcurpath, {\n        error: err\n      }, noop); // TODO v3.0\n      //me.emit('directoryError', me._wcurpath.replace(/^(.*)\\/.*$/, '$1'), { name: me._wcurpath.replace(/^.*\\/(.*)/, '$1'), error: err }, noop);\n\n      me._wReadFiles();\n\n      return;\n    } // error? first run? => maybe a file, maybe a true error\n\n\n    me._wfirstrun = false; // readdir failed (might be a file), try a stat on the parent\n\n    parent = me._wcurpath.replace(/^(.*)\\/.*$/, '$1');\n\n    fs[me._wStat](parent, function (e, stat) {\n      if (stat) {\n        // success\n        // now try stat on this as a child of the parent directory\n        child = me._wcurpath.replace(/^.*\\/(.*)$/, '$1');\n        me._wcurfiles = [child];\n        me._wcurpath = parent;\n      } else {\n        // TODO v3.0\n        //me.emit('directoryError', me._wcurpath.replace(/^(.*)\\/.*$/, '$1'), { name: me._wcurpath.replace(/^.*\\/(.*)/, '$1'), error: err }, noop);\n        // TODO v3.0 (don't noop the next)\n        // the original readdir error, not the parent stat error\n        me.emit('nodeError', me._wcurpath, {\n          error: err\n        }, noop);\n      }\n\n      me._wReadFiles();\n    });\n  };\n\n  Walker.prototype._wFilter = function () {\n    var me = this,\n        exclude; // Stop directories that contain filter keywords\n    // from continuing through the walk process\n\n    exclude = me._wfilters.some(function (filter) {\n      if (me._wcurpath.match(filter)) {\n        return true;\n      }\n    });\n    return exclude;\n  };\n\n  Walker.prototype._wWalkSync = function () {\n    //console.log('walkSync');\n    var err,\n        files,\n        me = this;\n\n    try {\n      files = fs.readdirSync(me._wcurpath);\n    } catch (e) {\n      err = e;\n    }\n\n    me._wReaddirHandler(err, files);\n  };\n\n  Walker.prototype._wWalkAsync = function () {\n    //console.log('walkAsync');\n    var me = this; // TODO how to remove this anony?\n\n    fs.readdir(me._wcurpath, function (err, files) {\n      me._wReaddirHandler(err, files);\n    });\n  };\n\n  Walker.prototype._wNext = function () {\n    var me = this;\n\n    if (me._paused) {\n      return;\n    }\n\n    if (me._wq.length) {\n      me._wcurpath = me._wq.pop();\n\n      while (me._wq.length && me._wFilter()) {\n        me._wcurpath = me._wq.pop();\n      }\n\n      if (me._wcurpath && !me._wFilter()) {\n        me._wWalk();\n      } else {\n        me._wNext();\n      }\n\n      return;\n    }\n\n    me._wqueue.length -= 1;\n\n    if (me._wqueue.length) {\n      me._wq = me._wqueue[me._wqueue.length - 1];\n      return me._wNext();\n    } // To not break compatibility\n    //process.nextTick(function () {\n\n\n    me.emit('end'); //});\n  };\n\n  Walker.prototype._wJoinPath = function (v, i, o) {\n    var me = this;\n    o[i] = [me._wcurpath, path.sep, v].join('');\n  };\n\n  Walker.prototype.pause = function () {\n    this._paused = true;\n  };\n\n  Walker.prototype.resume = function () {\n    this._paused = false;\n\n    this._wNext();\n  };\n\n  exports.walk = function (path, opts) {\n    return new Walker(path, opts, false);\n  };\n\n  exports.walkSync = function (path, opts) {\n    return new Walker(path, opts, true);\n  };\n})();","map":{"version":3,"sources":["C:/Users/H P/node_modules/walk/lib/walk.js"],"names":["noop","fs","require","forEachAsync","EventEmitter","TypeEmitter","util","path","appendToDirs","stat","flag","NO_DESCEND","push","name","wFilesHandlerWrapper","items","_wFilesHandler","Walker","pathname","options","sync","call","me","_wStat","followLinks","_wStatSync","_wsync","_wq","_wqueue","_wcurpath","undefined","_wfilters","filters","_wfirstrun","_wWalk","_wWalkSync","_wWalkAsync","listeners","Object","keys","forEach","event","callbacks","callback","on","inherits","prototype","_wLstatHandler","err","_wcurfile","error","emit","_wfnodegroups","errors","_wCurFileCallback","sortFnodesByType","emitNodeType","cont","file","statPath","sep","e","_wOnEmitDone","dirs","directories","_wJoinPath","_wNext","_wPostFilesHandler","length","emitNodeTypeGroups","_wReadFiles","_wcurfiles","then","_wReaddirHandler","files","fnodeGroups","createNodeGroups","parent","child","replace","_wFilter","exclude","some","filter","match","readdirSync","readdir","_paused","pop","v","i","o","join","pause","resume","exports","walk","opts","walkSync"],"mappings":"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","sourcesContent":["// Adapted from work by jorge@jorgechamorro.com on 2010-11-25\n(function () {\n  \"use strict\";\n\n  function noop() {}\n\n  var fs = require('fs')\n    , forEachAsync = require('foreachasync').forEachAsync\n    , EventEmitter = require('events').EventEmitter\n    , TypeEmitter = require('./node-type-emitter')\n    , util = require('util')\n    , path = require('path')\n    ;\n\n  function appendToDirs(stat) {\n    /*jshint validthis:true*/\n    if(stat.flag && stat.flag === NO_DESCEND) { return; }\n    this.push(stat.name);\n  }\n\n  function wFilesHandlerWrapper(items) {\n    /*jshint validthis:true*/\n    this._wFilesHandler(noop, items);\n  }\n\n  function Walker(pathname, options, sync) {\n    EventEmitter.call(this);\n\n    var me = this\n      ;\n\n    options = options || {};\n    me._wStat = options.followLinks && 'stat' || 'lstat';\n    me._wStatSync = me._wStat + 'Sync';\n    me._wsync = sync;\n    me._wq = [];\n    me._wqueue = [me._wq];\n    me._wcurpath = undefined;\n    me._wfilters = options.filters || [];\n    me._wfirstrun = true;\n    me._wcurpath = pathname;\n\n    if (me._wsync) {\n      //console.log('_walkSync');\n      me._wWalk = me._wWalkSync;\n    } else {\n      //console.log('_walkASync');\n      me._wWalk = me._wWalkAsync;\n    }\n\n    options.listeners = options.listeners || {};\n    Object.keys(options.listeners).forEach(function (event) {\n      var callbacks = options.listeners[event]\n        ;\n\n      if ('function' === typeof callbacks) {\n        callbacks = [callbacks];\n      }\n\n      callbacks.forEach(function (callback) {\n        me.on(event, callback);\n      });\n    });\n\n    me._wWalk();\n  }\n\n  // Inherits must come before prototype additions\n  util.inherits(Walker, EventEmitter);\n\n  Walker.prototype._wLstatHandler = function (err, stat) {\n    var me = this\n      ;\n\n    stat = stat || {};\n    stat.name = me._wcurfile;\n\n    if (err) {\n      stat.error = err;\n      //me.emit('error', curpath, stat);\n      // TODO v3.0 (don't noop the next if there are listeners)\n      me.emit('nodeError', me._wcurpath, stat, noop);\n      me._wfnodegroups.errors.push(stat);\n      me._wCurFileCallback();\n    } else {\n      TypeEmitter.sortFnodesByType(stat, me._wfnodegroups);\n      // NOTE: wCurFileCallback doesn't need thisness, so this is okay\n      TypeEmitter.emitNodeType(me, me._wcurpath, stat, me._wCurFileCallback, me);\n    }\n  };\n  Walker.prototype._wFilesHandler = function (cont, file) {\n    var statPath\n      , me = this\n      ;\n\n\n    me._wcurfile = file;\n    me._wCurFileCallback = cont;\n    me.emit('name', me._wcurpath, file, noop);\n\n    statPath = me._wcurpath + path.sep + file;\n\n    if (!me._wsync) {\n      // TODO how to remove this anony?\n      fs[me._wStat](statPath, function (err, stat) {\n        me._wLstatHandler(err, stat);\n      });\n      return;\n    }\n\n    try {\n      me._wLstatHandler(null, fs[me._wStatSync](statPath));\n    } catch(e) {\n      me._wLstatHandler(e);\n    }\n  };\n  Walker.prototype._wOnEmitDone = function () {\n    var me = this\n      , dirs = []\n      ;\n\n    me._wfnodegroups.directories.forEach(appendToDirs, dirs);\n    dirs.forEach(me._wJoinPath, me);\n    me._wqueue.push(me._wq = dirs);\n    me._wNext();\n  };\n  Walker.prototype._wPostFilesHandler = function () {\n    var me = this\n      ;\n\n    if (me._wfnodegroups.errors.length) {\n      // TODO v3.0 (don't noop the next)\n      // .errors is an array of stats with { name: name, error: error }\n      me.emit('errors', me._wcurpath, me._wfnodegroups.errors, noop);\n    }\n    // XXX emitNodeTypes still needs refactor\n    TypeEmitter.emitNodeTypeGroups(me, me._wcurpath, me._wfnodegroups, me._wOnEmitDone, me);\n  };\n  Walker.prototype._wReadFiles = function () {\n    var me = this\n      ;\n\n    if (!me._wcurfiles || 0 === me._wcurfiles.length) {\n      return me._wNext();\n    }\n\n    // TODO could allow user to selectively stat\n    // and don't stat if there are no stat listeners\n    me.emit('names', me._wcurpath, me._wcurfiles, noop);\n\n    if (me._wsync) {\n      me._wcurfiles.forEach(wFilesHandlerWrapper, me);\n      me._wPostFilesHandler();\n    } else {\n      forEachAsync(me._wcurfiles, me._wFilesHandler, me).then(me._wPostFilesHandler);\n    }\n  };\n  Walker.prototype._wReaddirHandler = function (err, files) {\n    var fnodeGroups = TypeEmitter.createNodeGroups()\n      , me = this\n      , parent\n      , child\n      ;\n\n    me._wfnodegroups = fnodeGroups;\n    me._wcurfiles = files;\n\n    // no error, great\n    if (!err) {\n      me._wReadFiles();\n      return;\n    }\n\n    // TODO path.sep\n    me._wcurpath = me._wcurpath.replace(/\\/$/, '');\n\n    // error? not first run? => directory error\n    if (!me._wfirstrun) {\n      // TODO v3.0 (don't noop the next if there are listeners)\n      me.emit('directoryError', me._wcurpath, { error: err }, noop);\n      // TODO v3.0\n      //me.emit('directoryError', me._wcurpath.replace(/^(.*)\\/.*$/, '$1'), { name: me._wcurpath.replace(/^.*\\/(.*)/, '$1'), error: err }, noop);\n      me._wReadFiles();\n      return;\n    }\n\n    // error? first run? => maybe a file, maybe a true error\n    me._wfirstrun = false;\n\n    // readdir failed (might be a file), try a stat on the parent\n    parent = me._wcurpath.replace(/^(.*)\\/.*$/, '$1');\n    fs[me._wStat](parent, function (e, stat) {\n\n      if (stat) {\n        // success\n        // now try stat on this as a child of the parent directory\n        child = me._wcurpath.replace(/^.*\\/(.*)$/, '$1');\n        me._wcurfiles = [child];\n        me._wcurpath = parent;\n      } else {\n        // TODO v3.0\n        //me.emit('directoryError', me._wcurpath.replace(/^(.*)\\/.*$/, '$1'), { name: me._wcurpath.replace(/^.*\\/(.*)/, '$1'), error: err }, noop);\n        // TODO v3.0 (don't noop the next)\n        // the original readdir error, not the parent stat error\n        me.emit('nodeError', me._wcurpath, { error: err }, noop);\n      }\n\n      me._wReadFiles();\n    });\n  };\n  Walker.prototype._wFilter = function () {\n    var me = this\n      , exclude\n      ;\n\n    // Stop directories that contain filter keywords\n    // from continuing through the walk process\n    exclude = me._wfilters.some(function (filter) {\n      if (me._wcurpath.match(filter)) {\n        return true;\n      }\n    });\n\n    return exclude;\n  };\n  Walker.prototype._wWalkSync = function () {\n    //console.log('walkSync');\n    var err\n      , files\n      , me = this\n      ;\n\n    try {\n      files = fs.readdirSync(me._wcurpath);\n    } catch(e) {\n      err = e;\n    }\n\n    me._wReaddirHandler(err, files);\n  };\n  Walker.prototype._wWalkAsync = function () {\n    //console.log('walkAsync');\n    var me = this\n      ;\n\n    // TODO how to remove this anony?\n    fs.readdir(me._wcurpath, function (err, files) {\n      me._wReaddirHandler(err, files);\n    });\n  };\n  Walker.prototype._wNext = function () {\n    var me = this\n      ;\n\n    if (me._paused) {\n      return;\n    }\n    if (me._wq.length) {\n      me._wcurpath = me._wq.pop();\n      while (me._wq.length && me._wFilter()) {\n        me._wcurpath = me._wq.pop();\n      }\n      if (me._wcurpath && !me._wFilter()) {\n        me._wWalk();\n      } else {\n        me._wNext();\n      }\n      return;\n    }\n    me._wqueue.length -= 1;\n    if (me._wqueue.length) {\n      me._wq = me._wqueue[me._wqueue.length - 1];\n      return me._wNext();\n    }\n\n    // To not break compatibility\n    //process.nextTick(function () {\n      me.emit('end');\n    //});\n  };\n  Walker.prototype._wJoinPath = function (v, i, o) {\n    var me = this\n      ;\n\n    o[i] = [me._wcurpath, path.sep, v].join('');\n  };\n  Walker.prototype.pause = function () {\n    this._paused = true;\n  };\n  Walker.prototype.resume = function () {\n    this._paused = false;\n    this._wNext();\n  };\n\n  exports.walk = function (path, opts) {\n    return new Walker(path, opts, false);\n  };\n\n  exports.walkSync = function (path, opts) {\n    return new Walker(path, opts, true);\n  };\n}());\n"]},"metadata":{},"sourceType":"script"}